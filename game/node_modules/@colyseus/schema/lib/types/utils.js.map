{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/types/utils.ts"],"names":[],"mappings":";;;AACA,gCAAoC;AAEpC,SAAgB,WAAW,CACvB,UAAwC,EACxC,EAAa,EACb,QAAuC,EACvC,QAAsE;IAEtE,+BAA+B;IAC/B,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE;QACjB,UAAU,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC;KACvB;IAED,UAAU,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAE9B,EAAE;IACF,yCAAyC;IACzC,kBAAkB;IAClB,sBAAsB;IACtB,EAAE;IACF,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,OAAO,CAAC,UAAC,IAAI,EAAE,GAAG,IAAK,OAAA,QAAQ,CAAC,IAAI,EAAE,GAAG,CAAC,EAAnB,CAAmB,CAAC,CAAC;IAEtD,OAAO,cAAM,OAAA,SAAS,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE,UAAU,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,EAA3D,CAA2D,CAAC;AAC7E,CAAC;AArBD,kCAqBC;AAGD,SAAgB,eAAe,CAAyB,OAAqB;IAA7E,iBAgBC;IAfG,IAAM,aAAa,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC,KAAK,QAAQ,CAAC,CAAC;IAEtE,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,UAAC,IAAS,EAAE,GAAQ;QACpC,OAAO,CAAC,IAAI,CAAC;YACT,KAAK,EAAE,KAAI,CAAC,QAAQ,CAAC,KAAK;YAC1B,EAAE,EAAE,gBAAS,CAAC,MAAM;YACpB,KAAK,EAAE,GAAG;YACV,KAAK,EAAE,SAAS;YAChB,aAAa,EAAE,IAAI;SACtB,CAAC,CAAC;QAEH,IAAI,aAAa,EAAE;YACf,KAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC,CAAC;SACxD;IACL,CAAC,CAAC,CAAC;AACP,CAAC;AAhBD,0CAgBC;AAGD,SAAgB,SAAS,CAAC,GAAU,EAAE,KAAa;IAC/C,2BAA2B;IAC3B,IAAI,KAAK,KAAK,CAAC,CAAC,IAAI,KAAK,IAAI,GAAG,CAAC,MAAM,EAAE;QACrC,OAAO,KAAK,CAAC;KAChB;IAED,IAAM,GAAG,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC;IAE3B,KAAK,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;QAC9B,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;KACvB;IAED,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC;IAEjB,OAAO,IAAI,CAAC;AAChB,CAAC;AAfD,8BAeC","sourcesContent":["import { CollectionSchema, DataChange } from \"..\";\nimport { OPERATION } from \"../spec\";\n\nexport function addCallback(\n    $callbacks: { [op: number]: Function[] },\n    op: OPERATION,\n    callback: (item: any, key: any) => void,\n    existing?: { forEach(callback: (item: any, key: any) => void): void; }\n) {\n    // initialize list of callbacks\n    if (!$callbacks[op]) {\n        $callbacks[op] = [];\n    }\n\n    $callbacks[op].push(callback);\n\n    //\n    // Trigger callback for existing elements\n    // - OPERATION.ADD\n    // - OPERATION.REPLACE\n    //\n    existing?.forEach((item, key) => callback(item, key));\n\n    return () => spliceOne($callbacks[op], $callbacks[op].indexOf(callback));\n}\n\n\nexport function removeChildRefs(this: CollectionSchema, changes: DataChange[]) {\n    const needRemoveRef = (typeof (this.$changes.getType()) !== \"string\");\n\n    this.$items.forEach((item: any, key: any) => {\n        changes.push({\n            refId: this.$changes.refId,\n            op: OPERATION.DELETE,\n            field: key,\n            value: undefined,\n            previousValue: item\n        });\n\n        if (needRemoveRef) {\n            this.$changes.root.removeRef(item['$changes'].refId);\n        }\n    });\n}\n\n\nexport function spliceOne(arr: any[], index: number): boolean {\n    // manually splice an array\n    if (index === -1 || index >= arr.length) {\n        return false;\n    }\n\n    const len = arr.length - 1;\n\n    for (let i = index; i < len; i++) {\n        arr[i] = arr[i + 1];\n    }\n\n    arr.length = len;\n\n    return true;\n}"]}
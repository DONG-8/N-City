"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.spliceOne = exports.removeChildRefs = exports.addCallback = void 0;
var spec_1 = require("../spec");
function addCallback($callbacks, op, callback, existing) {
    // initialize list of callbacks
    if (!$callbacks[op]) {
        $callbacks[op] = [];
    }
    $callbacks[op].push(callback);
    //
    // Trigger callback for existing elements
    // - OPERATION.ADD
    // - OPERATION.REPLACE
    //
    existing === null || existing === void 0 ? void 0 : existing.forEach(function (item, key) { return callback(item, key); });
    return function () { return spliceOne($callbacks[op], $callbacks[op].indexOf(callback)); };
}
exports.addCallback = addCallback;
function removeChildRefs(changes) {
    var _this = this;
    var needRemoveRef = (typeof (this.$changes.getType()) !== "string");
    this.$items.forEach(function (item, key) {
        changes.push({
            refId: _this.$changes.refId,
            op: spec_1.OPERATION.DELETE,
            field: key,
            value: undefined,
            previousValue: item
        });
        if (needRemoveRef) {
            _this.$changes.root.removeRef(item['$changes'].refId);
        }
    });
}
exports.removeChildRefs = removeChildRefs;
function spliceOne(arr, index) {
    // manually splice an array
    if (index === -1 || index >= arr.length) {
        return false;
    }
    var len = arr.length - 1;
    for (var i = index; i < len; i++) {
        arr[i] = arr[i + 1];
    }
    arr.length = len;
    return true;
}
exports.spliceOne = spliceOne;
//# sourceMappingURL=utils.js.map
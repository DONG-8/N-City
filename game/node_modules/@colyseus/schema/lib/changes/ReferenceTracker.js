"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReferenceTracker = void 0;
var Schema_1 = require("../Schema");
var ReferenceTracker = /** @class */ (function () {
    function ReferenceTracker() {
        //
        // Relation of refId => Schema structure
        // For direct access of structures during decoding time.
        //
        this.refs = new Map();
        this.refCounts = {};
        this.deletedRefs = new Set();
        this.nextUniqueId = 0;
    }
    ReferenceTracker.prototype.getNextUniqueId = function () {
        return this.nextUniqueId++;
    };
    // for decoding
    ReferenceTracker.prototype.addRef = function (refId, ref, incrementCount) {
        if (incrementCount === void 0) { incrementCount = true; }
        this.refs.set(refId, ref);
        if (incrementCount) {
            this.refCounts[refId] = (this.refCounts[refId] || 0) + 1;
        }
    };
    // for decoding
    ReferenceTracker.prototype.removeRef = function (refId) {
        this.refCounts[refId] = this.refCounts[refId] - 1;
        this.deletedRefs.add(refId);
    };
    ReferenceTracker.prototype.clearRefs = function () {
        this.refs.clear();
        this.deletedRefs.clear();
        this.refCounts = {};
    };
    // for decoding
    ReferenceTracker.prototype.garbageCollectDeletedRefs = function () {
        var _this = this;
        this.deletedRefs.forEach(function (refId) {
            //
            // Skip active references.
            //
            if (_this.refCounts[refId] > 0) {
                return;
            }
            var ref = _this.refs.get(refId);
            //
            // Ensure child schema instances have their references removed as well.
            //
            if (ref instanceof Schema_1.Schema) {
                for (var fieldName in ref['_definition'].schema) {
                    if (typeof (ref['_definition'].schema[fieldName]) !== "string" &&
                        ref[fieldName] &&
                        ref[fieldName]['$changes']) {
                        _this.removeRef(ref[fieldName]['$changes'].refId);
                    }
                }
            }
            else {
                var definition = ref['$changes'].parent._definition;
                var type = definition.schema[definition.fieldsByIndex[ref['$changes'].parentIndex]];
                if (typeof (Object.values(type)[0]) === "function") {
                    Array.from(ref.values())
                        .forEach(function (child) { return _this.removeRef(child['$changes'].refId); });
                }
            }
            _this.refs.delete(refId);
            delete _this.refCounts[refId];
        });
        // clear deleted refs.
        this.deletedRefs.clear();
    };
    return ReferenceTracker;
}());
exports.ReferenceTracker = ReferenceTracker;
//# sourceMappingURL=ReferenceTracker.js.map
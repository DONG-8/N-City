'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var nanoid = require('nanoid');
var Debug = require('./Debug.js');
var require$$0 = require('events');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var nanoid__default = /*#__PURE__*/_interopDefaultLegacy(nanoid);

// remote room call timeouts
const REMOTE_ROOM_SHORT_TIMEOUT = Number(process.env.COLYSEUS_PRESENCE_SHORT_TIMEOUT || 2000);
function generateId(length = 9) {
    return nanoid__default['default'](length);
}
//
// nodemon sends SIGUSR2 before reloading
// (https://github.com/remy/nodemon#controlling-shutdown-of-your-script)
//
const signals = ['SIGINT', 'SIGTERM', 'SIGUSR2'];
function registerGracefulShutdown(callback) {
    /**
     * Gracefully shutdown on uncaught errors
     */
    process.on('uncaughtException', (err) => {
        Debug.debugAndPrintError(err);
        callback(err);
    });
    signals.forEach((signal) => process.once(signal, () => callback()));
}
function retry(cb, maxRetries = 3, errorWhiteList = [], retries = 0) {
    return new Promise((resolve, reject) => {
        cb()
            .then(resolve)
            .catch((e) => {
            if (errorWhiteList.indexOf(e.constructor) !== -1 &&
                retries++ < maxRetries) {
                setTimeout(() => {
                    retry(cb, maxRetries, errorWhiteList, retries).
                        then(resolve).
                        catch((e2) => reject(e2));
                }, Math.floor(Math.random() * Math.pow(2, retries) * 400));
            }
            else {
                reject(e);
            }
        });
    });
}
function spliceOne(arr, index) {
    // manually splice availableRooms array
    // http://jsperf.com/manual-splice
    if (index === -1 || index >= arr.length) {
        return false;
    }
    const len = arr.length - 1;
    for (let i = index; i < len; i++) {
        arr[i] = arr[i + 1];
    }
    arr.length = len;
    return true;
}
class Deferred {
    promise;
    resolve;
    reject;
    constructor() {
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
    then(func) {
        return this.promise.then.apply(this.promise, arguments);
    }
    catch(func) {
        return this.promise.catch(func);
    }
}
function merge(a, ...objs) {
    for (let i = 0, len = objs.length; i < len; i++) {
        const b = objs[i];
        for (const key in b) {
            if (b.hasOwnProperty(key)) {
                a[key] = b[key];
            }
        }
    }
    return a;
}
class HybridArray {
    uniqueProperty;
    hashedArray;
    array;
    constructor(uniquePropertyName, elements) {
        this.uniqueProperty = uniquePropertyName;
        this.hashedArray = {};
        this.array = [];
        if (elements) {
            this.array = this.array.concat(elements);
            for (const element of elements) {
                this.hashedArray[element[this.uniqueProperty]] = element;
            }
        }
    }
    get length() {
        return this.array.length;
    }
    add(element) {
        if (!this.hashedArray[element[this.uniqueProperty]]) {
            this.array.push(element);
            this.hashedArray[element[this.uniqueProperty]] = element;
        }
        else {
            console.error(`Element already exists for ${this.uniqueProperty}: '${element[this.uniqueProperty]}'.`);
        }
    }
    at(index) {
        if (index >= this.array.length) {
            this.indexError(index);
        }
        else {
            return this.array[index];
        }
    }
    concat(elements) {
        if (elements) {
            for (const element of elements) {
                this.hashedArray[element[this.uniqueProperty]] = element;
            }
            this.array.concat(elements);
        }
    }
    forEach(fn) {
        for (let element of this.array) {
            fn(element);
        }
    }
    get(key) {
        return this.hashedArray[key];
    }
    includes(element) {
        return this.hashedArray[element[this.uniqueProperty]] !== undefined;
    }
    indexOf(element) {
        return this.array.indexOf(element);
    }
    map(callback) {
        const result = [];
        for (let index = 0; index < this.array.length; index++) {
            result.push(callback(this.array[index], index, this.array));
        }
        return result;
    }
    deleteAt(index) {
        if (index >= this.array.length) {
            this.indexError(index);
            return undefined;
        }
        else {
            const removable = this.spliceOne(index);
            delete this.hashedArray[removable[this.uniqueProperty]];
            return removable;
        }
    }
    deleteByKey(key) {
        if (!this.hashedArray[key]) {
            this.invalidKeyError(key);
            return undefined;
        }
        else {
            const removable = this.spliceOne(this.indexOf(this.hashedArray[key]));
            delete this.hashedArray[key];
            return removable;
        }
    }
    delete(obj) {
        if (this.hashedArray[obj[this.uniqueProperty]]) {
            return this.deleteByKey(obj[this.uniqueProperty]);
        }
        else if (this.indexOf(obj) != -1) {
            return this.deleteAt(this.indexOf(obj));
        }
        else {
            console.error("Invalid object has been provided!");
            return undefined;
        }
    }
    indexError(index) {
        console.error(`Index out of range, index: ${index}`);
    }
    invalidKeyError(key) {
        console.error(`No such element for property '${this.uniqueProperty}': '${key}'.`);
    }
    spliceOne(index) {
        // manually splice availableRooms array
        // http://jsperf.com/manual-splice
        if (index === -1 || index >= this.array.length) {
            this.indexError(index);
            return undefined;
        }
        const removable = this.array[index];
        const len = this.array.length - 1;
        for (let i = index; i < len; i++) {
            this.array[i] = this.array[i + 1];
        }
        this.array.length = len;
        return removable;
    }
}
class DummyServer extends require$$0.EventEmitter {
}

exports.Deferred = Deferred;
exports.DummyServer = DummyServer;
exports.HybridArray = HybridArray;
exports.REMOTE_ROOM_SHORT_TIMEOUT = REMOTE_ROOM_SHORT_TIMEOUT;
exports.generateId = generateId;
exports.merge = merge;
exports.registerGracefulShutdown = registerGracefulShutdown;
exports.retry = retry;
exports.spliceOne = spliceOne;
//# sourceMappingURL=Utils.js.map

{"version":3,"file":"getSchemaTypes.mjs","sources":["../../../../../../../../node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nconst Mixed = require('../../schema/mixed');\nconst get = require('../get');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst mpath = require('mpath');\n\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\n\n/*!\n * @param {Schema} schema\n * @param {Object} doc POJO\n * @param {string} path\n */\n\nmodule.exports = function getSchemaTypes(schema, doc, path) {\n  const pathschema = schema.path(path);\n  const topLevelDoc = doc;\n  if (pathschema) {\n    return pathschema;\n  }\n\n  function search(parts, schema, subdoc, nestedPath) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema == null) {\n        continue;\n      }\n\n      if (foundschema.caster) {\n        // array of Mixed?\n        if (foundschema.caster instanceof Mixed) {\n          return foundschema.caster;\n        }\n\n        let schemas = null;\n        if (foundschema.schema != null && foundschema.schema.discriminators != null) {\n          const discriminators = foundschema.schema.discriminators;\n          const discriminatorKeyPath = trypath + '.' +\n            foundschema.schema.options.discriminatorKey;\n          const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];\n          schemas = Object.keys(discriminators).\n            reduce(function(cur, discriminator) {\n              const tiedValue = discriminators[discriminator].discriminatorMapping.value;\n              if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {\n                cur.push(discriminators[discriminator]);\n              }\n              return cur;\n            }, []);\n        }\n\n        // Now that we found the array, we need to check if there\n        // are remaining document paths to look up for casting.\n        // Also we need to handle array.$.path since schema.path\n        // doesn't work for that.\n        // If there is no foundschema.schema we are dealing with\n        // a path like array.$\n        if (p !== parts.length && foundschema.schema) {\n          let ret;\n          if (parts[p] === '$') {\n            if (p + 1 === parts.length) {\n              // comments.$\n              return foundschema;\n            }\n            // comments.$.comments.$.title\n            ret = search(\n              parts.slice(p + 1),\n              schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n            if (ret) {\n              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                !foundschema.schema.$isSingleNested;\n            }\n            return ret;\n          }\n\n          if (schemas != null && schemas.length > 0) {\n            ret = [];\n            for (const schema of schemas) {\n              const _ret = search(\n                parts.slice(p),\n                schema,\n                subdoc ? mpath.get(trypath, subdoc) : null,\n                nestedPath.concat(parts.slice(0, p))\n              );\n              if (_ret != null) {\n                _ret.$isUnderneathDocArray = _ret.$isUnderneathDocArray ||\n                  !foundschema.schema.$isSingleNested;\n                if (_ret.$isUnderneathDocArray) {\n                  ret.$isUnderneathDocArray = true;\n                }\n                ret.push(_ret);\n              }\n            }\n            return ret;\n          } else {\n            ret = search(\n              parts.slice(p),\n              foundschema.schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n\n            if (ret) {\n              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                !foundschema.schema.$isSingleNested;\n            }\n            return ret;\n          }\n        } else if (p !== parts.length &&\n            foundschema.$isMongooseArray &&\n            foundschema.casterConstructor.$isMongooseArray) {\n          // Nested arrays. Drill down to the bottom of the nested array.\n          let type = foundschema;\n          while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n            type = type.casterConstructor;\n          }\n\n          const ret = search(\n            parts.slice(p),\n            type.schema,\n            null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n          if (ret != null) {\n            return ret;\n          }\n\n          if (type.schema.discriminators) {\n            const discriminatorPaths = [];\n            for (const discriminatorName of Object.keys(type.schema.discriminators)) {\n              const _schema = type.schema.discriminators[discriminatorName] || type.schema;\n              const ret = search(parts.slice(p), _schema, null, nestedPath.concat(parts.slice(0, p)));\n              if (ret != null) {\n                discriminatorPaths.push(ret);\n              }\n            }\n            if (discriminatorPaths.length > 0) {\n              return discriminatorPaths;\n            }\n          }\n        }\n      }\n\n      const fullPath = nestedPath.concat([trypath]).join('.');\n      if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.populated(fullPath) && p < parts.length) {\n        const model = doc.$__.populated[fullPath].options[populateModelSymbol];\n        if (model != null) {\n          const ret = search(\n            parts.slice(p),\n            model.schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          if (ret) {\n            ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n              !model.schema.$isSingleNested;\n          }\n          return ret;\n        }\n      }\n\n      const _val = get(topLevelDoc, trypath);\n      if (_val != null) {\n        const model = Array.isArray(_val) && _val.length > 0 ?\n          leanPopulateMap.get(_val[0]) :\n          leanPopulateMap.get(_val);\n        // Populated using lean, `leanPopulateMap` value is the foreign model\n        const schema = model != null ? model.schema : null;\n        if (schema != null) {\n          const ret = search(\n            parts.slice(p),\n            schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          if (ret != null) {\n            ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n              !schema.$isSingleNested;\n            return ret;\n          }\n        }\n      }\n      return foundschema;\n    }\n  }\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$') {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, schema, doc, []);\n};\n"],"names":["require$$0","Mixed"],"mappings":"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"}
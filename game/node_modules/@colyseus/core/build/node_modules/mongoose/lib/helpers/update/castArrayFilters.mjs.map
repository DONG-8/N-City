{"version":3,"file":"castArrayFilters.mjs","sources":["../../../../../../../../node_modules/mongoose/lib/helpers/update/castArrayFilters.js"],"sourcesContent":["'use strict';\n\nconst castFilterPath = require('../query/castFilterPath');\nconst cleanPositionalOperators = require('../schema/cleanPositionalOperators');\nconst getPath = require('../schema/getPath');\nconst updatedPathsByArrayFilter = require('./updatedPathsByArrayFilter');\n\nmodule.exports = function castArrayFilters(query) {\n  const arrayFilters = query.options.arrayFilters;\n  if (!Array.isArray(arrayFilters)) {\n    return;\n  }\n\n  const update = query.getUpdate();\n  const schema = query.schema;\n  const strictQuery = schema.options.strictQuery;\n\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n\n  for (const filter of arrayFilters) {\n    if (filter == null) {\n      throw new Error(`Got null array filter in ${arrayFilters}`);\n    }\n    for (const key of Object.keys(filter)) {\n      if (filter[key] == null) {\n        continue;\n      }\n\n      const dot = key.indexOf('.');\n      let filterPath = dot === -1 ?\n        updatedPathsByFilter[key] + '.0' :\n        updatedPathsByFilter[key.substr(0, dot)] + '.0' + key.substr(dot);\n\n      if (filterPath == null) {\n        throw new Error(`Filter path not found for ${key}`);\n      }\n\n      // If there are multiple array filters in the path being updated, make sure\n      // to replace them so we can get the schema path.\n      filterPath = cleanPositionalOperators(filterPath);\n\n      const schematype = getPath(schema, filterPath);\n      if (schematype == null) {\n        if (!strictQuery) {\n          return;\n        }\n        // For now, treat `strictQuery = true` and `strictQuery = 'throw'` as\n        // equivalent for casting array filters. `strictQuery = true` doesn't\n        // quite work in this context because we never want to silently strip out\n        // array filters, even if the path isn't in the schema.\n        throw new Error(`Could not find path \"${filterPath}\" in schema`);\n      }\n      if (typeof filter[key] === 'object') {\n        filter[key] = castFilterPath(query, schematype, filter[key]);\n      } else {\n        filter[key] = schematype.castForQuery(filter[key]);\n      }\n    }\n  }\n};"],"names":[],"mappings":";;;;;oBAOc,GAAG,SAAS,gBAAgB,CAAC,KAAK,EAAE;AAClD,EAAE,MAAM,YAAY,GAAG,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC;AAClD,EAAE,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE;AACpC,IAAI,OAAO;AACX,GAAG;AACH;AACA,EAAE,MAAM,MAAM,GAAG,KAAK,CAAC,SAAS,EAAE,CAAC;AACnC,EAAE,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;AAC9B,EAAE,MAAM,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC;AACjD;AACA,EAAE,MAAM,oBAAoB,GAAG,yBAAyB,CAAC,MAAM,CAAC,CAAC;AACjE;AACA,EAAE,KAAK,MAAM,MAAM,IAAI,YAAY,EAAE;AACrC,IAAI,IAAI,MAAM,IAAI,IAAI,EAAE;AACxB,MAAM,MAAM,IAAI,KAAK,CAAC,CAAC,yBAAyB,EAAE,YAAY,CAAC,CAAC,CAAC,CAAC;AAClE,KAAK;AACL,IAAI,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;AAC3C,MAAM,IAAI,MAAM,CAAC,GAAG,CAAC,IAAI,IAAI,EAAE;AAC/B,QAAQ,SAAS;AACjB,OAAO;AACP;AACA,MAAM,MAAM,GAAG,GAAG,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;AACnC,MAAM,IAAI,UAAU,GAAG,GAAG,KAAK,CAAC,CAAC;AACjC,QAAQ,oBAAoB,CAAC,GAAG,CAAC,GAAG,IAAI;AACxC,QAAQ,oBAAoB,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,IAAI,GAAG,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AAC1E;AACA,MAAM,IAAI,UAAU,IAAI,IAAI,EAAE;AAC9B,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,0BAA0B,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;AAC5D,OAAO;AACP;AACA;AACA;AACA,MAAM,UAAU,GAAG,wBAAwB,CAAC,UAAU,CAAC,CAAC;AACxD;AACA,MAAM,MAAM,UAAU,GAAG,OAAO,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;AACrD,MAAM,IAAI,UAAU,IAAI,IAAI,EAAE;AAC9B,QAAQ,IAAI,CAAC,WAAW,EAAE;AAC1B,UAAU,OAAO;AACjB,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,qBAAqB,EAAE,UAAU,CAAC,WAAW,CAAC,CAAC,CAAC;AACzE,OAAO;AACP,MAAM,IAAI,OAAO,MAAM,CAAC,GAAG,CAAC,KAAK,QAAQ,EAAE;AAC3C,QAAQ,MAAM,CAAC,GAAG,CAAC,GAAG,cAAc,CAAC,KAAK,EAAE,UAAU,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;AACrE,OAAO,MAAM;AACb,QAAQ,MAAM,CAAC,GAAG,CAAC,GAAG,UAAU,CAAC,YAAY,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;AAC3D,OAAO;AACP,KAAK;AACL,GAAG;AACH;;;;"}
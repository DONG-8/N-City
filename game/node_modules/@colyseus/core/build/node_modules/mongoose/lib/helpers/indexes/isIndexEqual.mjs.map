{"version":3,"file":"isIndexEqual.mjs","sources":["../../../../../../../../node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js"],"sourcesContent":["'use strict';\n\nconst get = require('../get');\nconst utils = require('../../utils');\n\n/**\n * Given a Mongoose index definition (key + options objects) and a MongoDB server\n * index definition, determine if the two indexes are equal.\n *\n * @param {Object} key the Mongoose index spec\n * @param {Object} options the Mongoose index definition's options\n * @param {Object} dbIndex the index in MongoDB as returned by `listIndexes()`\n * @api private\n */\n\nmodule.exports = function isIndexEqual(key, options, dbIndex) {\n  // Special case: text indexes have a special format in the db. For example,\n  // `{ name: 'text' }` becomes:\n  // {\n  //   v: 2,\n  //   key: { _fts: 'text', _ftsx: 1 },\n  //   name: 'name_text',\n  //   ns: 'test.tests',\n  //   background: true,\n  //   weights: { name: 1 },\n  //   default_language: 'english',\n  //   language_override: 'language',\n  //   textIndexVersion: 3\n  // }\n  if (dbIndex.textIndexVersion != null) {\n    const weights = dbIndex.weights;\n    if (Object.keys(weights).length !== Object.keys(key).length) {\n      return false;\n    }\n    for (const prop of Object.keys(weights)) {\n      if (!(prop in key)) {\n        return false;\n      }\n      const weight = weights[prop];\n      if (weight !== get(options, 'weights.' + prop) && !(weight === 1 && get(options, 'weights.' + prop) == null)) {\n        return false;\n      }\n    }\n\n    if (options['default_language'] !== dbIndex['default_language']) {\n      return dbIndex['default_language'] === 'english' && options['default_language'] == null;\n    }\n\n    return true;\n  }\n\n  const optionKeys = [\n    'unique',\n    'partialFilterExpression',\n    'sparse',\n    'expireAfterSeconds',\n    'collation'\n  ];\n  for (const key of optionKeys) {\n    if (!(key in options) && !(key in dbIndex)) {\n      continue;\n    }\n    if (key === 'collation') {\n      if (options[key] == null || dbIndex[key] == null) {\n        return options[key] == null && dbIndex[key] == null;\n      }\n      const definedKeys = Object.keys(options.collation);\n      const schemaCollation = options.collation;\n      const dbCollation = dbIndex.collation;\n      for (const opt of definedKeys) {\n        if (get(schemaCollation, opt) !== get(dbCollation, opt)) {\n          return false;\n        }\n      }\n    } else if (!utils.deepEqual(options[key], dbIndex[key])) {\n      return false;\n    }\n  }\n\n  const schemaIndexKeys = Object.keys(key);\n  const dbIndexKeys = Object.keys(dbIndex.key);\n  if (schemaIndexKeys.length !== dbIndexKeys.length) {\n    return false;\n  }\n  for (let i = 0; i < schemaIndexKeys.length; ++i) {\n    if (schemaIndexKeys[i] !== dbIndexKeys[i]) {\n      return false;\n    }\n    if (!utils.deepEqual(key[schemaIndexKeys[i]], dbIndex.key[dbIndexKeys[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n"],"names":[],"mappings":"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"}
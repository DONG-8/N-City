{"version":3,"file":"assignRawDocsToIdStructure.mjs","sources":["../../../../../../../../node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js"],"sourcesContent":["'use strict';\n\nconst leanPopulateMap = require('./leanPopulateMap');\nconst modelSymbol = require('../symbols').modelSymbol;\nconst utils = require('../../utils');\n\nmodule.exports = assignRawDocsToIdStructure;\n\n/*!\n * Assign `vals` returned by mongo query to the `rawIds`\n * structure returned from utils.getVals() honoring\n * query sort order if specified by user.\n *\n * This can be optimized.\n *\n * Rules:\n *\n *   if the value of the path is not an array, use findOne rules, else find.\n *   for findOne the results are assigned directly to doc path (including null results).\n *   for find, if user specified sort order, results are assigned directly\n *   else documents are put back in original order of array if found in results\n *\n * @param {Array} rawIds\n * @param {Array} vals\n * @param {Boolean} sort\n * @api private\n */\n\nfunction assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {\n  // honor user specified sort order\n  const newOrder = [];\n  const sorting = options.sort && rawIds.length > 1;\n  const nullIfNotFound = options.$nullIfNotFound;\n  let doc;\n  let sid;\n  let id;\n\n  for (let i = 0; i < rawIds.length; ++i) {\n    id = rawIds[i];\n\n    if (Array.isArray(id)) {\n      // handle [ [id0, id2], [id3] ]\n      assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);\n      newOrder.push(id);\n      continue;\n    }\n\n    if (id === null && !sorting) {\n      // keep nulls for findOne unless sorting, which always\n      // removes them (backward compat)\n      newOrder.push(id);\n      continue;\n    }\n\n    sid = String(id);\n\n    doc = resultDocs[sid];\n    // If user wants separate copies of same doc, use this option\n    if (options.clone && doc != null) {\n      if (options.lean) {\n        const _model = leanPopulateMap.get(doc);\n        doc = utils.clone(doc);\n        leanPopulateMap.set(doc, _model);\n      } else {\n        doc = doc.constructor.hydrate(doc._doc);\n      }\n    }\n\n    if (recursed) {\n      if (doc) {\n        if (sorting) {\n          newOrder[resultOrder[sid]] = doc;\n        } else {\n          newOrder.push(doc);\n        }\n      } else if (id != null && id[modelSymbol] != null) {\n        newOrder.push(id);\n      } else {\n        newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);\n      }\n    } else {\n      // apply findOne behavior - if document in results, assign, else assign null\n      newOrder[i] = doc || null;\n    }\n  }\n\n  rawIds.length = 0;\n  if (newOrder.length) {\n    // reassign the documents based on corrected order\n\n    // forEach skips over sparse entries in arrays so we\n    // can safely use this to our advantage dealing with sorted\n    // result sets too.\n    newOrder.forEach(function(doc, i) {\n      rawIds[i] = doc;\n    });\n  }\n}"],"names":["require$$0"],"mappings":"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"}
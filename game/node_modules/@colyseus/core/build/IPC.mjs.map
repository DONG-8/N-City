{"version":3,"file":"IPC.mjs","sources":["../src/IPC.ts"],"sourcesContent":["import { debugAndPrintError } from './Debug';\nimport { Presence } from './presence/Presence';\nimport { IpcProtocol } from './Protocol';\nimport { generateId, REMOTE_ROOM_SHORT_TIMEOUT } from './Utils';\n\nexport async function requestFromIPC<T>(\n  presence: Presence,\n  publishToChannel: string,\n  method: string,\n  args: any[],\n  rejectionTimeout: number = REMOTE_ROOM_SHORT_TIMEOUT,\n): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    let unsubscribeTimeout: NodeJS.Timer;\n\n    const requestId = generateId();\n    const channel = `ipc:${requestId}`;\n\n    const unsubscribe = () => {\n      presence.unsubscribe(channel);\n      clearTimeout(unsubscribeTimeout);\n    };\n\n    presence.subscribe(channel, (message) => {\n      const [code, data] = message;\n      if (code === IpcProtocol.SUCCESS) {\n        resolve(data);\n      } else if (code === IpcProtocol.ERROR) {\n        reject(data);\n      }\n      unsubscribe();\n    });\n\n    presence.publish(publishToChannel, [method, requestId, args]);\n\n    unsubscribeTimeout = setTimeout(() => {\n      unsubscribe();\n      reject(`IPC timed out. method: ${method}, args: ${JSON.stringify(args)}`);\n    }, rejectionTimeout);\n  });\n}\n\nexport async function subscribeIPC(\n  presence: Presence,\n  processId: string,\n  channel: string,\n  replyCallback: (method: string, args: any[]) => any,\n) {\n  await presence.subscribe(channel, (message) => {\n    const [method, requestId, args] = message;\n\n    const reply = (code, data) => {\n      presence.publish(`ipc:${requestId}`, [code, data]);\n    };\n\n    // reply with method result\n    let response: any;\n    try {\n      response = replyCallback(method, args);\n\n    } catch (e) {\n      debugAndPrintError(e);\n      return reply(IpcProtocol.ERROR, e.message || e);\n    }\n\n    if (!(response instanceof Promise)) {\n      return reply(IpcProtocol.SUCCESS, response);\n    }\n\n    response.\n      then((result) => reply(IpcProtocol.SUCCESS, result)).\n      catch((e) => {\n        // user might have called `reject()` without arguments.\n        const err = e && e.message || e;\n        reply(IpcProtocol.ERROR, err);\n      });\n  });\n}\n"],"names":[],"mappings":";;;;AAKO,eAAe,cAAc,CAClC,QAAkB,EAClB,gBAAwB,EACxB,MAAc,EACd,IAAW,EACX,mBAA2B,yBAAyB;IAEpD,OAAO,IAAI,OAAO,CAAI,CAAC,OAAO,EAAE,MAAM;QACpC,IAAI,kBAAgC,CAAC;QAErC,MAAM,SAAS,GAAG,UAAU,EAAE,CAAC;QAC/B,MAAM,OAAO,GAAG,OAAO,SAAS,EAAE,CAAC;QAEnC,MAAM,WAAW,GAAG;YAClB,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;YAC9B,YAAY,CAAC,kBAAkB,CAAC,CAAC;SAClC,CAAC;QAEF,QAAQ,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC,OAAO;YAClC,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,OAAO,CAAC;YAC7B,IAAI,IAAI,KAAK,WAAW,CAAC,OAAO,EAAE;gBAChC,OAAO,CAAC,IAAI,CAAC,CAAC;aACf;iBAAM,IAAI,IAAI,KAAK,WAAW,CAAC,KAAK,EAAE;gBACrC,MAAM,CAAC,IAAI,CAAC,CAAC;aACd;YACD,WAAW,EAAE,CAAC;SACf,CAAC,CAAC;QAEH,QAAQ,CAAC,OAAO,CAAC,gBAAgB,EAAE,CAAC,MAAM,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC,CAAC;QAE9D,kBAAkB,GAAG,UAAU,CAAC;YAC9B,WAAW,EAAE,CAAC;YACd,MAAM,CAAC,0BAA0B,MAAM,WAAW,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;SAC3E,EAAE,gBAAgB,CAAC,CAAC;KACtB,CAAC,CAAC;AACL,CAAC;AAEM,eAAe,YAAY,CAChC,QAAkB,EAClB,SAAiB,EACjB,OAAe,EACf,aAAmD;IAEnD,MAAM,QAAQ,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC,OAAO;QACxC,MAAM,CAAC,MAAM,EAAE,SAAS,EAAE,IAAI,CAAC,GAAG,OAAO,CAAC;QAE1C,MAAM,KAAK,GAAG,CAAC,IAAI,EAAE,IAAI;YACvB,QAAQ,CAAC,OAAO,CAAC,OAAO,SAAS,EAAE,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;SACpD,CAAC;;QAGF,IAAI,QAAa,CAAC;QAClB,IAAI;YACF,QAAQ,GAAG,aAAa,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;SAExC;QAAC,OAAO,CAAC,EAAE;YACV,kBAAkB,CAAC,CAAC,CAAC,CAAC;YACtB,OAAO,KAAK,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,CAAC;SACjD;QAED,IAAI,EAAE,QAAQ,YAAY,OAAO,CAAC,EAAE;YAClC,OAAO,KAAK,CAAC,WAAW,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;SAC7C;QAED,QAAQ;YACN,IAAI,CAAC,CAAC,MAAM,KAAK,KAAK,CAAC,WAAW,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;YACpD,KAAK,CAAC,CAAC,CAAC;;YAEN,MAAM,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC;YAChC,KAAK,CAAC,WAAW,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;SAC/B,CAAC,CAAC;KACN,CAAC,CAAC;AACL;;;;"}